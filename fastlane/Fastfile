default_platform(:ios)

platform :ios do
  # Reads App Store Connect API key from ENV (see CI below)
  def asc_api_key
    app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_KEY_CONTENT_BASE64"],
      is_key_content_base64: true
    )
  end

  desc "Preflight (project settings) then verify App ID exists and is explicit"
  lane :preflight do
    require "shellwords"
    preflight_script = File.expand_path("../ci/signing_preflight.sh", __dir__)
    sh("bash #{Shellwords.escape(preflight_script)}")

    api_key = asc_api_key

    # Pull bundle id from project to avoid drift
    scheme = ENV["SCHEME"] || "GrindLab"
    configuration = ENV["CONFIGURATION"] || "Release"
    project_path = ENV["PROJECT"] || File.expand_path("../GrindLab.xcodeproj", __dir__)
    destination = ENV["DESTINATION"] || "generic/platform=iOS"
    derived_data_path = ENV["DERIVED_DATA_PATH"] || File.expand_path("../.derived_data", __dir__)
    Actions.sh("mkdir -p #{Shellwords.escape(derived_data_path)}")
    settings_output = Actions.sh(<<~CMD)
      set -o pipefail && xcodebuild \
        -showBuildSettings \
        -project #{Shellwords.escape(project_path)} \
        -scheme #{Shellwords.escape(scheme)} \
        -configuration #{Shellwords.escape(configuration)} \
        -destination #{Shellwords.escape(destination)} \
        -derivedDataPath #{Shellwords.escape(derived_data_path)} \
        -json 2>&1
CMD
    json_start = settings_output.index("[")
    UI.user_error!("Unable to parse xcodebuild build settings JSON") unless json_start
    settings = settings_output[json_start..-1]
    require "json"
    parsed = JSON.parse(settings)[0]["buildSettings"]
    bundle_id = parsed["PRODUCT_BUNDLE_IDENTIFIER"]

    UI.user_error!("No PRODUCT_BUNDLE_IDENTIFIER found") unless bundle_id

    begin
      require "spaceship"
      token = Spaceship::ConnectAPI.token
      unless token.is_a?(Spaceship::ConnectAPI::Token)
        Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(**api_key)
      end

      bundle = nil
      begin
        bundle = Spaceship::ConnectAPI::BundleId.find(bundle_id)
      rescue NoMethodError => e
        UI.message("ConnectAPI::BundleId.find failed (#{e.message}); trying fallback lookup")
      end

      if bundle.nil? && Spaceship::ConnectAPI.respond_to?(:get_bundle_ids)
        begin
          response = Spaceship::ConnectAPI.get_bundle_ids(filter: { identifier: bundle_id })
          bundle = response.to_models.first if response.respond_to?(:to_models)
          bundle ||= response.first if response.respond_to?(:first)
        rescue NoMethodError => e
          UI.message("ConnectAPI.get_bundle_ids fallback failed (#{e.message})")
        end
      end

      UI.user_error!("No App ID found in App Store Connect for #{bundle_id}") unless bundle

      bundle_attributes =
        if bundle.is_a?(Hash)
          bundle["attributes"] || bundle
        elsif bundle.respond_to?(:attributes)
          bundle.attributes || {}
        else
          {}
        end

      identifier =
        if bundle.respond_to?(:identifier)
          bundle.identifier
        elsif bundle.respond_to?(:bundle_id)
          bundle.bundle_id
        elsif bundle_attributes.is_a?(Hash)
          bundle_attributes["identifier"]
        end

      bundle_type =
        if bundle.respond_to?(:bundle_id_type)
          bundle.bundle_id_type
        elsif bundle.respond_to?(:type) && !bundle.is_a?(Hash)
          bundle.type
        elsif bundle_attributes.is_a?(Hash)
          bundle_attributes["type"]
        elsif bundle.is_a?(Hash)
          bundle["type"]
        end

      UI.user_error!("Unable to read bundle identifier from ASC response") unless identifier
      if bundle_type.to_s.casecmp("WILDCARD").zero?
        UI.user_error!("App ID is wildcard; need explicit App ID (#{identifier})")
      end

      UI.success("✅ Explicit App ID exists: #{identifier}")
    rescue => e
      UI.user_error!("Bundle lookup via App Store Connect failed: #{e.message}")
    end
  end

  # Optional: use match to fetch signing certs/profiles (recommended for CI)
  # Set MATCH_GIT_URL + MATCH_PASSWORD (and optionally MATCH_BRANCH) in CI.
  desc "Sync signing via match (readonly true in CI)"
  lane :sync_signing do
    if ENV["MATCH_GIT_URL"].to_s.empty?
      UI.message("Skipping match: MATCH_GIT_URL not set")
      next
    end
    type = ENV["MATCH_TYPE"] || "appstore"
    match(
      type: type,
      readonly: true,
      git_url: ENV["MATCH_GIT_URL"],
      git_branch: ENV["MATCH_BRANCH"],
      git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTH"], # optional PAT
      app_identifier: [ENV["BUNDLE_ID"]].compact, # can be nil, match will infer if repo has it
      username: ENV["APPLE_ID"] # optional; API key handles ASC, but certs still need Portal access
    )
  end

  desc "Archive with gym"
  lane :build do
    scheme = ENV["SCHEME"] || "GrindLab"
    configuration = ENV["CONFIGURATION"] || "Release"

    gym(
      scheme: scheme,
      configuration: configuration,
      clean: true,
      export_method: "app-store",
      output_directory: "build",
      output_name: "#{scheme}.ipa",
      include_bitcode: false, # modern Xcode ignores, but safe
      silent: false
    )
  end

  desc "Upload IPA to TestFlight"
  lane :upload do
    api_key = asc_api_key
    ipa_path = Dir["build/*.ipa"].first
    UI.user_error!("IPA not found in build/") unless ipa_path

    pilot(
      api_key: api_key,
      ipa: ipa_path,
      distribute_external: false,              # flip to true when ready
      skip_waiting_for_build_processing: true  # CI should end quickly
    )
  end

  desc "CI pipeline: preflight → (match) → build → upload"
  lane :ci do
    preflight
    sync_signing
    build
    upload
  end
end
